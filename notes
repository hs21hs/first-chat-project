potential issues/ questions:
-learn what are the memory/speed implications. querying the db then mutating the response. of refining ur query so u get back a resp closer to what you want
-when we set state we use a set timeout for the next function
-when you login/signup without a user it crashes, how can we catch this error etc?
-general error catching
-{ 
    why when passing (const currentUser = userOne) from test is the same as (const currentUser = {currentUser:userOne}) from frontend?
}
-when testing the same endpoint for different ponints{
    should you have one test which returns multiple errors or should you have multiple tests as it is easier to read?
    -if it is the latter, having multiple tests for the same endpoint.{
        -should you write the test defensively or optimistically as described in "tests/users.test.js" test('A users newMessage attribute should read as true, if they have sent an unread message to current user')
        defensively: you assume the test is failaing and pass it if you find a reason to.
        optimistically: you assume the test is passing and fail it if you find a reason to.
    }
}

general notes:
-userSchema.static is for model/ userSchema.methods is for the instance

to do:
-maybe try to auth websockets and maybe test them
-create validation that you cant send a message to yourself
-how do u stop sql injcetions (force a check on what keys are permitted)
-decide what the project will be
-set up basic tests for messages endpoints

- in auth.js understand why we need to acces tokens thru a string const user = await User.findOne({ _id: decoded._id, 'tokens.token': token })